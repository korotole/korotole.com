<!DOCTYPE html>
<html>

<head>
  <title>korotole | books</title>
  {{template "Metadata"}}
</head>

<body>
  <div class="b-page">

    {{template "Topper"}}

    <div class="tabs-nav">
      <div class="tab-special">
        <button class="tab-button tablink active" onclick="openTab(event,'Edit')">âœï¸</button>
      </div>
      <div class="tabs">
        <button class="tab-button tablink" onclick="openTab(event,'Finished')">ğŸ Finished</button>
        <button class="tab-button tablink" onclick="openTab(event,'Planned')">ğŸ“Œ Planned</button>
      </div>
      <div class="tab-special">
        <button class="tab-button tablink" onclick="openTab(event,'Search')">ğŸ”</button>
      </div>
    </div>

    <div id="Edit" class="subtabs-nav">

      <div class="tab-vertical-buttons-left" >
        <div class="tab-special-v" id="AddBtn">
          <button class="tab-button subtablink" onclick="openSubTab(event,'Add')">â•</button>
        </div>
        <div class="tab-special-v" id="DeleteBtn">
          <button class="tab-button subtablink" onclick="openSubTab(event,'Delete')">â–</button>
        </div>
      </div>

      <div id="Add" class="subtab-content" style="display:none">
        <h2>Add a book</h2>
        <p>!!!!!!!!</p>
      </div>
      <div id="Delete" class="subtab-content" style="display:none">
        <h2>Remove a book</h2>
        <p>??????</p>
      </div>
    </div>

    <div id="Search" class="tab-content" style="display:none">
      <h2>Search</h2>
      <p>Search for books.</p>
    </div>

    <div id="Finished" class="tab-content" style="display:none">
      <h2>Finished</h2>
      <p>Search for books.</p>
      <div class="book">
        <h2>Herculaneum Scrolls</h2>
        <p>V informatice se jednÃ¡ o odbornÃ½ technickÃ½ pojem, kterÃ½m je oznaÄen zvlÃ¡Å¡tnÃ­ datovÃ½ typ (bÄ›Å¾nÄ›jÅ¡Ã­ je string
          nebo Å™etÄ›zec) nebo datovÃ½ formÃ¡t. Text je cokoliv, co je uloÅ¾eno v textovÃ©m formÃ¡tu (t.j. pÅ™Ã­mo v textovÃ½ch
          znacÃ­ch, kÃ³dovanÃ½ch napÅ™. v ASCII, ANSI, Unicode, UTF-8, â€¦), a to i v pÅ™Ã­padÄ›, Å¾e danÃ½ textovÃ½ Å™etÄ›zec
          (posloupnost znakÅ¯) nedÃ¡vÃ¡ Å¾Ã¡dnÃ½ smysl v Å¾Ã¡dnÃ©m pÅ™irozenÃ©m ani formÃ¡lnÃ­m jazyce, a dokonce i v pÅ™Ã­padÄ›, Å¾e
          dÃ©lka textu je nulovÃ¡ (0 znakÅ¯). PodstatnÃ½ je zde typ nebo formÃ¡t, kde pevnÃ©mu poÄtu bajtÅ¯ (poÄÃ­taÄovÃ½ch slov)
          odpovÃ­dÃ¡ vÅ¾dy konkrÃ©tnÃ­ znak danÃ© abecedy.

          Text (dle jazykovÄ›dy, tj. posloupnost slov, nesoucÃ­ vÃ½znam) nakreslenÃ½ v obrÃ¡zku (tj. napÅ™. vyfotografovanÃ¡
          cedule s nÃ¡pisem) nenÃ­ z pohledu informatiky â€prostÃ½m textemâ€œ (anglicky plain text), neboÅ¥ â€z pohledu
          poÄÃ­taÄeâ€œ se jiÅ¾ nejednÃ¡ o soubor pÃ­smen, ale o binÃ¡rnÃ­ data grafickÃ½ch objektÅ¯ (rÅ¯znÄ› barevnÃ© body, kÅ™ivky,
          â€¦) respektive se jednÃ¡ o datovÃ½ typ nebo formÃ¡t, jenÅ¾ nenÃ­ z hlediska informatiky povaÅ¾ovÃ¡n za textovÃ½. V
          tomto formÃ¡tu text nenÃ­ zakÃ³dovÃ¡n po jednotlivÃ½ch znacÃ­ch danÃ© abecedy v danÃ©m poÄtu bajtÅ¯.

          NicmÃ©nÄ›, dekÃ³dovÃ¡nÃ­ pÅ¯vodnÃ­ho textu z rÅ¯znÃ½ch grafickÃ½ch netextovÃ½ch formÃ¡tÅ¯ je dnes bÄ›Å¾nÄ› moÅ¾nÃ© pomocÃ­
          specializovanÃ©ho software, napÅ™. pomocÃ­ OCR programÅ¯ s relativnÄ› vysokou mÃ­rou pÅ™esnosti. </p>
      </div>

      <div class="book">
        <h2>Ancient Scrolls</h2>
        <p>V informatice se jednÃ¡ o odbornÃ½ technickÃ½ pojem, kterÃ½m je oznaÄen zvlÃ¡Å¡tnÃ­ datovÃ½ typ (bÄ›Å¾nÄ›jÅ¡Ã­ je string
          nebo Å™etÄ›zec) nebo datovÃ½ formÃ¡t. Text je cokoliv, co je uloÅ¾eno v textovÃ©m formÃ¡tu (t.j. pÅ™Ã­mo v textovÃ½ch
          znacÃ­ch, kÃ³dovanÃ½ch napÅ™. v ASCII, ANSI, Unicode, UTF-8, â€¦), a to i v pÅ™Ã­padÄ›, Å¾e danÃ½ textovÃ½ Å™etÄ›zec
          (posloupnost znakÅ¯) nedÃ¡vÃ¡ Å¾Ã¡dnÃ½ smysl v Å¾Ã¡dnÃ©m pÅ™irozenÃ©m ani formÃ¡lnÃ­m jazyce, a dokonce i v pÅ™Ã­padÄ›, Å¾e
          dÃ©lka textu je nulovÃ¡ (0 znakÅ¯). PodstatnÃ½ je zde typ nebo formÃ¡t, kde pevnÃ©mu poÄtu bajtÅ¯ (poÄÃ­taÄovÃ½ch slov)
          odpovÃ­dÃ¡ vÅ¾dy konkrÃ©tnÃ­ znak danÃ© abecedy.

          Text (dle jazykovÄ›dy, tj. posloupnost slov, nesoucÃ­ vÃ½znam) nakreslenÃ½ v obrÃ¡zku (tj. napÅ™. vyfotografovanÃ¡
          cedule s nÃ¡pisem) nenÃ­ z pohledu informatiky â€prostÃ½m textemâ€œ (anglicky plain text), neboÅ¥ â€z pohledu
          poÄÃ­taÄeâ€œ se jiÅ¾ nejednÃ¡ o soubor pÃ­smen, ale o binÃ¡rnÃ­ data grafickÃ½ch objektÅ¯ (rÅ¯znÄ› barevnÃ© body, kÅ™ivky,
          â€¦) respektive se jednÃ¡ o datovÃ½ typ nebo formÃ¡t, jenÅ¾ nenÃ­ z hlediska informatiky povaÅ¾ovÃ¡n za textovÃ½. V
          tomto formÃ¡tu text nenÃ­ zakÃ³dovÃ¡n po jednotlivÃ½ch znacÃ­ch danÃ© abecedy v danÃ©m poÄtu bajtÅ¯.

          NicmÃ©nÄ›, dekÃ³dovÃ¡nÃ­ pÅ¯vodnÃ­ho textu z rÅ¯znÃ½ch grafickÃ½ch netextovÃ½ch formÃ¡tÅ¯ je dnes bÄ›Å¾nÄ› moÅ¾nÃ© pomocÃ­
          specializovanÃ©ho software, napÅ™. pomocÃ­ OCR programÅ¯ s relativnÄ› vysokou mÃ­rou pÅ™esnosti. </p>
      </div>

    </div>

    <div id="Planned" class="tab-content" style="display:none">
      <h2>Planned</h2>
      <p>List of books that are to be read.</p>
      <div class="book">
        Programming Scrolls
      </div>
    </div>


    {{template "Footer" .}}

  </div>
</body>

<script>
  function openTab(evt, tabName) {
    var i, x, tablinks;
    x = document.getElementsByClassName("tab-content");
    for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablink");
    for (i = 0; i < x.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  function openSubTab(evt, tabName) {
    var i, x, tablinks;
    x = document.getElementsByClassName("subtab-content");
    for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("subtablink");
    for (i = 0; i < x.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  document.querySelectorAll('.book').forEach(book => {
    const resizer = document.createElement('div');
    resizer.className = 'resizer';
    book.appendChild(resizer);
    book.classList.add('resizable');

    // Constants
    const MIN_HEIGHT = 80;
    const MAX_HEIGHT = 800;
    const STEP = 1;
    const SCROLL_SPEED = 10; // Speed of auto-scrolling
    const SCROLL_BOUNDARY = 85; // How close to the viewport edge to trigger scrolling

    // Variables for drag state
    let startY, startHeight;
    let isDragging = false;
    let autoScrollIntervalId = null;

    const initDrag = function (e) {
      if (e.type === 'mousedown') {
        e.preventDefault();
        e.stopPropagation();
      }

      // Get starting positions
      startY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      startHeight = parseInt(window.getComputedStyle(book).height, 10);
      isDragging = true;
      book.classList.add('dragging');

      document.addEventListener('mousemove', doDrag, { passive: false });
      document.addEventListener('touchmove', doDrag, { passive: false });
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchend', stopDrag);
      document.addEventListener('touchcancel', stopDrag);
    };

    let animationFrameId = null;

    const doDrag = function (e) {
      if (!isDragging) return;
      e.preventDefault();

      // Get current position
      const currentY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      const viewportHeight = window.innerHeight;

      // Get book boundaries
      const bookRect = book.getBoundingClientRect();
      const header = document.querySelector('header') || document.getElementById('header');
      const headerBottom = header ? header.getBoundingClientRect().bottom : 0;

      // Check if we need to auto-scroll
      if (currentY > viewportHeight - SCROLL_BOUNDARY) {
        // Near bottom of viewport - start scrolling down if not already
        if (!autoScrollIntervalId) {
          autoScrollIntervalId = setInterval(() => {
            window.scrollBy(0, SCROLL_SPEED);
          }, 16); // ~60fps
        }
      } else if (currentY < headerBottom + SCROLL_BOUNDARY) {
        // Near top/header - start scrolling up if not already
        if (!autoScrollIntervalId) {
          autoScrollIntervalId = setInterval(() => {
            window.scrollBy(0, -SCROLL_SPEED);
          }, 16); // ~60fps
        }
      } else {
        // Not near edges, stop auto-scrolling
        if (autoScrollIntervalId) {
          clearInterval(autoScrollIntervalId);
          autoScrollIntervalId = null;
        }
      }

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      animationFrameId = requestAnimationFrame(() => {
        // Calculate new height
        const rawHeight = startHeight + currentY - startY;
        const snapped = Math.round(rawHeight / STEP) * STEP;

        // Apply minimum height constraint
        let finalHeight = Math.max(MIN_HEIGHT, snapped);

        // Check if the top of the book is below header
        if (bookRect.top < headerBottom) {
          // Don't allow resizing if it would push the top above the header
          finalHeight = Math.min(finalHeight, bookRect.height);
        }

        // Apply maximum height constraint
        finalHeight = Math.min(finalHeight, MAX_HEIGHT);

        // Apply the height
        book.style.height = finalHeight + 'px';
      });
    };

    const stopDrag = function () {
      if (!isDragging) return;

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      if (autoScrollIntervalId) {
        clearInterval(autoScrollIntervalId);
        autoScrollIntervalId = null;
      }

      isDragging = false;
      book.classList.remove('dragging');

      document.removeEventListener('mousemove', doDrag);
      document.removeEventListener('touchmove', doDrag);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchend', stopDrag);
      document.removeEventListener('touchcancel', stopDrag);
    };

    resizer.addEventListener('mousedown', initDrag, { passive: false });
    resizer.addEventListener('touchstart', initDrag, { passive: true });
  });
</script>

</html>