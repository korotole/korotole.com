<!DOCTYPE html>
<html>

<head>
  <title>korotole | books</title>
  {{template "Metadata"}}
</head>

<body>
  <div class="b-page">

    {{template "Topper"}}

    <div class="tabs-nav">
      <div class="tab-special">
        <button class="tab-button tablink active" onclick="openTab(event,'Edit')">✏️</button>
      </div>
      <div class="tabs">
        <button class="tab-button tablink" onclick="openTab(event,'Finished')">🏁 Finished</button>
        <button class="tab-button tablink" onclick="openTab(event,'Planned')">📌 Planned</button>
      </div>
      <div class="tab-special">
        <button class="tab-button tablink" onclick="openTab(event,'Search')">🔍</button>
      </div>
    </div>

    <div id="Edit" class="subtabs-nav">

      <div class="tab-vertical-buttons-left" >
        <div class="tab-special-v" id="AddBtn">
          <button class="tab-button subtablink" onclick="openSubTab(event,'Add')">➕</button>
        </div>
        <div class="tab-special-v" id="DeleteBtn">
          <button class="tab-button subtablink" onclick="openSubTab(event,'Delete')">➖</button>
        </div>
      </div>

      <div id="Add" class="subtab-content" style="display:none">
        <h2>Add a book</h2>
        <p>!!!!!!!!</p>
      </div>
      <div id="Delete" class="subtab-content" style="display:none">
        <h2>Remove a book</h2>
        <p>??????</p>
      </div>
    </div>

    <div id="Search" class="tab-content" style="display:none">
      <h2>Search</h2>
      <p>Search for books.</p>
    </div>

    <div id="Finished" class="tab-content" style="display:none">
      <h2>Finished</h2>
      <p>Search for books.</p>
      <div class="book">
        <h2>Herculaneum Scrolls</h2>
        <p>V informatice se jedná o odborný technický pojem, kterým je označen zvláštní datový typ (běžnější je string
          nebo řetězec) nebo datový formát. Text je cokoliv, co je uloženo v textovém formátu (t.j. přímo v textových
          znacích, kódovaných např. v ASCII, ANSI, Unicode, UTF-8, …), a to i v případě, že daný textový řetězec
          (posloupnost znaků) nedává žádný smysl v žádném přirozeném ani formálním jazyce, a dokonce i v případě, že
          délka textu je nulová (0 znaků). Podstatný je zde typ nebo formát, kde pevnému počtu bajtů (počítačových slov)
          odpovídá vždy konkrétní znak dané abecedy.

          Text (dle jazykovědy, tj. posloupnost slov, nesoucí význam) nakreslený v obrázku (tj. např. vyfotografovaná
          cedule s nápisem) není z pohledu informatiky „prostým textem“ (anglicky plain text), neboť „z pohledu
          počítače“ se již nejedná o soubor písmen, ale o binární data grafických objektů (různě barevné body, křivky,
          …) respektive se jedná o datový typ nebo formát, jenž není z hlediska informatiky považován za textový. V
          tomto formátu text není zakódován po jednotlivých znacích dané abecedy v daném počtu bajtů.

          Nicméně, dekódování původního textu z různých grafických netextových formátů je dnes běžně možné pomocí
          specializovaného software, např. pomocí OCR programů s relativně vysokou mírou přesnosti. </p>
      </div>

      <div class="book">
        <h2>Ancient Scrolls</h2>
        <p>V informatice se jedná o odborný technický pojem, kterým je označen zvláštní datový typ (běžnější je string
          nebo řetězec) nebo datový formát. Text je cokoliv, co je uloženo v textovém formátu (t.j. přímo v textových
          znacích, kódovaných např. v ASCII, ANSI, Unicode, UTF-8, …), a to i v případě, že daný textový řetězec
          (posloupnost znaků) nedává žádný smysl v žádném přirozeném ani formálním jazyce, a dokonce i v případě, že
          délka textu je nulová (0 znaků). Podstatný je zde typ nebo formát, kde pevnému počtu bajtů (počítačových slov)
          odpovídá vždy konkrétní znak dané abecedy.

          Text (dle jazykovědy, tj. posloupnost slov, nesoucí význam) nakreslený v obrázku (tj. např. vyfotografovaná
          cedule s nápisem) není z pohledu informatiky „prostým textem“ (anglicky plain text), neboť „z pohledu
          počítače“ se již nejedná o soubor písmen, ale o binární data grafických objektů (různě barevné body, křivky,
          …) respektive se jedná o datový typ nebo formát, jenž není z hlediska informatiky považován za textový. V
          tomto formátu text není zakódován po jednotlivých znacích dané abecedy v daném počtu bajtů.

          Nicméně, dekódování původního textu z různých grafických netextových formátů je dnes běžně možné pomocí
          specializovaného software, např. pomocí OCR programů s relativně vysokou mírou přesnosti. </p>
      </div>

    </div>

    <div id="Planned" class="tab-content" style="display:none">
      <h2>Planned</h2>
      <p>List of books that are to be read.</p>
      <div class="book">
        Programming Scrolls
      </div>
    </div>


    {{template "Footer" .}}

  </div>
</body>

<script>
  function openTab(evt, tabName) {
    var i, x, tablinks;
    x = document.getElementsByClassName("tab-content");
    for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablink");
    for (i = 0; i < x.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  function openSubTab(evt, tabName) {
    var i, x, tablinks;
    x = document.getElementsByClassName("subtab-content");
    for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("subtablink");
    for (i = 0; i < x.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  document.querySelectorAll('.book').forEach(book => {
    const resizer = document.createElement('div');
    resizer.className = 'resizer';
    book.appendChild(resizer);
    book.classList.add('resizable');

    // Constants
    const MIN_HEIGHT = 80;
    const MAX_HEIGHT = 800;
    const STEP = 1;
    const SCROLL_SPEED = 10; // Speed of auto-scrolling
    const SCROLL_BOUNDARY = 85; // How close to the viewport edge to trigger scrolling

    // Variables for drag state
    let startY, startHeight;
    let isDragging = false;
    let autoScrollIntervalId = null;

    const initDrag = function (e) {
      if (e.type === 'mousedown') {
        e.preventDefault();
        e.stopPropagation();
      }

      // Get starting positions
      startY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      startHeight = parseInt(window.getComputedStyle(book).height, 10);
      isDragging = true;
      book.classList.add('dragging');

      document.addEventListener('mousemove', doDrag, { passive: false });
      document.addEventListener('touchmove', doDrag, { passive: false });
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchend', stopDrag);
      document.addEventListener('touchcancel', stopDrag);
    };

    let animationFrameId = null;

    const doDrag = function (e) {
      if (!isDragging) return;
      e.preventDefault();

      // Get current position
      const currentY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
      const viewportHeight = window.innerHeight;

      // Get book boundaries
      const bookRect = book.getBoundingClientRect();
      const header = document.querySelector('header') || document.getElementById('header');
      const headerBottom = header ? header.getBoundingClientRect().bottom : 0;

      // Check if we need to auto-scroll
      if (currentY > viewportHeight - SCROLL_BOUNDARY) {
        // Near bottom of viewport - start scrolling down if not already
        if (!autoScrollIntervalId) {
          autoScrollIntervalId = setInterval(() => {
            window.scrollBy(0, SCROLL_SPEED);
          }, 16); // ~60fps
        }
      } else if (currentY < headerBottom + SCROLL_BOUNDARY) {
        // Near top/header - start scrolling up if not already
        if (!autoScrollIntervalId) {
          autoScrollIntervalId = setInterval(() => {
            window.scrollBy(0, -SCROLL_SPEED);
          }, 16); // ~60fps
        }
      } else {
        // Not near edges, stop auto-scrolling
        if (autoScrollIntervalId) {
          clearInterval(autoScrollIntervalId);
          autoScrollIntervalId = null;
        }
      }

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      animationFrameId = requestAnimationFrame(() => {
        // Calculate new height
        const rawHeight = startHeight + currentY - startY;
        const snapped = Math.round(rawHeight / STEP) * STEP;

        // Apply minimum height constraint
        let finalHeight = Math.max(MIN_HEIGHT, snapped);

        // Check if the top of the book is below header
        if (bookRect.top < headerBottom) {
          // Don't allow resizing if it would push the top above the header
          finalHeight = Math.min(finalHeight, bookRect.height);
        }

        // Apply maximum height constraint
        finalHeight = Math.min(finalHeight, MAX_HEIGHT);

        // Apply the height
        book.style.height = finalHeight + 'px';
      });
    };

    const stopDrag = function () {
      if (!isDragging) return;

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }

      if (autoScrollIntervalId) {
        clearInterval(autoScrollIntervalId);
        autoScrollIntervalId = null;
      }

      isDragging = false;
      book.classList.remove('dragging');

      document.removeEventListener('mousemove', doDrag);
      document.removeEventListener('touchmove', doDrag);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchend', stopDrag);
      document.removeEventListener('touchcancel', stopDrag);
    };

    resizer.addEventListener('mousedown', initDrag, { passive: false });
    resizer.addEventListener('touchstart', initDrag, { passive: true });
  });
</script>

</html>